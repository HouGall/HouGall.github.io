---
title: MySQL数据库学习1
data: 2020-8-23 8:50:18
tags:
 - 数据库
 - 求职
categories:
 - 求职
mathjax: true
---
# MySQL基础
>MyISAM时mysql5.5版本之前的默认数据库引擎，虽然性能极佳并提供了大量特性，但是 **==不支持行级锁和事务 ，最大的缺陷是奔溃后无法安全恢复#F44336 #F44336==**。
>5.5后使用InnoDB（事务性数据库引擎）作为MySQL的默认引擎。
## InnoDB
>1.支持**行级锁和表级锁**，而MyISAM只支持表级锁。
>2.支持**事务**。MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。**==事务具有原子性，一致性，隔离性和持久性 #F44336==**。
>3.支持**奔溃后恢复**。具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
>4.支持**外键**。 MyISAM不支持，而InnoDB支持。
>5.支持MVCC（多版本并发控制）。**应对高并发事务, MVCC比单纯的加锁更高效**。

## 事务
>事务是逻辑上的一组操作，要么都执行，要么都不执行。
>[![四个特性](https://s1.ax1x.com/2020/08/24/dDtWhF.png)](https://imgchr.com/i/dDtWhF)
>原子性：指最小的单位，不可再分割，在事务执行时要么都执行，要么都不执行。
>一致性：执行事务前后，数据保持一致，多个事务对数据的读取结果是相同的。
>隔离性：并发访问数据库时，各事务保持相互独立，一个用户的事务不被其他事务干扰。
>持久性：一个事务提交后，他对数据库的改变是持久的，即使数据库发生故障也不会对其造成影响。

## 并发事务带来的问题。
>1.==脏读 #F44336==。一个事务正在访问数据并修改了数据，但是还没有提交到数据库，另一个事务也访问数据库并**使用未提交但修改的数据**，此时此事务读到的数据是为改变的数据，因此可能造成操作不正确。
>2.==丢失修改 #F44336==。一个事务访问数据并修改数据，另一个事务也访问数据并修改数据，那么会造成第一个事务修改的**数据被覆盖**。
>3.==不可重复读 #F44336==。一个事务多次读数据，另一个事务在第一个事务读数据期间访问数据并修改，会造成第一个事务多次**读到的数据不一致**。
>4.==幻读 #F44336==。第一个事务多次读数据，第二个事务在此期间访问数据并插入数据，那么第一个事务在**读数据时多了原本不存在的数据**。
## 四个隔离级别
>**READ-UNCOMMITTED**（读取未提交）：最低的隔离机制，允许读取未提交的数据，**可能会导致脏读，不可重复读和幻读。**
>**READ-COMMITED**（读取已提交）：允许读取并发事务提交的数据，**可能造成不可重复读和幻读**。
>**REPEATABLE-READ**（可重复读）：对同一字段的多次读取结果都一致，除非本事务修改了此字段。可能造成幻读。
>**SERIALIZABLE**（可串行化）：最高的隔离机制，完全满足ACID（事务四个特性），所有的事务逐个执行，各事务相互独立。该级别可防止脏读，不可重复读和幻读。

## MySQL锁
>mysql为了并发，数据安全，使用了锁机制。
>按照粒度分为表级锁和行级锁。
### 表级锁
>粒度最大的锁，**对当前操作的整张表加锁，实现简单，资源消耗少，加锁快，不会出现死锁**。但锁的粒度最大，所以触发锁冲突的几率更大，并发度最低，MyISAM和InnoDB都支持。

### 行级锁
>粒度最小的锁，只针对当前操作的行进行加锁，粒度最小，大大减小数据库的锁冲突，并发程度高，但是开销大，速度慢并且会死锁。
>InnoDB支持的行级锁有以下几种：
>>1.record-lock：对索引项加锁，锁定符合条件的索引项，其他事务不能修改和删除加锁项。
>>2.gap-lock：间隙锁，对索引项之间的“间隙”加锁。锁定范围内的行，其他事务不能在此范围插入数据。
>>3.next-lock：结合索引锁和间隙锁，防止幻读。

### 表级锁也有很大的作用，在更新表中大部分数据时，表级锁性能更高；在处理复杂的事务时，行级锁可能会造成死锁，表级锁也是性能更好。

### 锁分类
>表级锁和行级锁可以进一步划分为**共享锁(S)和排他锁(X)**。
#### 共享锁
>指的是**读锁**，是其他用**户可以并发读取数据**，但是其他事务不能获得加了共享锁的数据的排他锁，也就是说只有所有并发执行的共享锁都释放了，才能够让其他事务获得排他锁。
>即一个事务对数据施加了S锁，其他事务**只能对其施加S锁，不能施加X锁**。这可以保证在读数据期间只能进行读取不能改变。
### 排他锁
>指的是**写锁**。在对数据的**增删改上都是使用排他锁**。在一个事务对数据施加排他锁后，此事务可以对此数据**进行读取和修改**，但是**其他事务都不能对此数据时间S锁和X锁**，即其他事务无法对此数据进行读取和改变。
### 表级锁的分类
>分为意向共享锁（IS）和意向排他锁（IX）。
>**意向锁的作用就是表示一种意向，在事务访问的数据行被排他锁占用时，此事务可以在数据行所在的表上添加一个合适的意向锁，表明需要访问此数据。**
>其中意向共享锁可以有多个，而意向排他锁只能有一个。
>事务在**访问数据行的时候必须先要通过表级的的意向锁**，才能够再对数据行添加相应的锁。

## 死锁和避免死锁
>当事务请求的锁模式和当前的锁兼容时，那么就不会造成冲突，InnoDB就会将请求的锁给该事务，但是如果不兼容，那么该事务就需要等待锁释放才能获得锁。
>InnoDB的锁是逐步添加的，当两个事务都需要对方锁定的数据时，两个事物都会进入等待释放锁状态，此时就会发生死锁。InnoDB在发现死锁时，**会让一个事务释放锁并回退，两一个事务获得数据**。
>避免死锁：
>>**1.通过表级锁较小死锁概率。**
>>**2.使得多个程序约定尽量按照相同的顺序访问数据。（哲学家进餐问题）**
>>**3.同一个事务做到尽可能锁定所需的所有数据。**