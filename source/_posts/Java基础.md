## 1.继承、封装、多态怎么理解？

> 都可以在类的层次说明
>
> 多态：表示一个实例有多种状态。

## 2 .equals被重写后，hashcode（）为什么也要重写？

> equal如果没有被重写表示的是比较还是地址（基本类型除外）。
>
> hashcode（）是获取哈希码，也就是把对象进行哈希运算后返回值的哈希地址，而哈希对于相同的值哈希地址一定相同，哈希地址相同值却不一定相同（哈希碰撞）。
>
> 对象加入hash表中会先计算hashcode值来确定对象的hash地址，如果此地址没有分配，那么就把对象放在此位置，如果此位置有了对象，那么就会比较两个对象的equals，如果equals相同了，那么就表示是同一个对象，就不会让其加入，如果不想同，表示不同对象，将此对象散列到其他地方加入。
>
> 所以如果重写了equals，对于相同hashcode的对象，比较的值发生了改变，有可能发生相同对象都放进hash表中，造成浪费。

## 3.重写和重载的区别

> 重写：子类对父类中方法的重定义。
>
> 重载：同一个类中，同一个方法根据不同的参数个数做出不同的处理。

## 4.抽象类和接口的区别

> 抽象类：不能用private修饰，其他可以修饰；一般方法有方法体，抽象方法没有方法体，只能被继承类重写；不能多重继承。
>
> 接口：只能用static和final修饰，不能有其他修饰符；接口的所有方法都不能有方法体，只能在继承时重写；能够多重继承。

## 5.实例和实例中的方法在内存中怎么存在？

> 实例存储在JVM的堆中，堆中为每个实例划出内存存储实例。
>
> 实例的方法可以想为一个线程，存在jvm栈中，存储了实例方法的局部变量表，操作数栈等。

## 6.super（）的作用

> 子类继承父类时，如果有super()方法，会调用父类的无参构造函数初始化，然后再加上子类本身的初始化。
>
> 如果父类没有无参构造，会发生报错。

## 7.继承中子类对父类中私有方法和实例方法的权限

> 私有方法：子类只能拥有，不能访问
>
> 实例方法：无限制

## 8.实例方法和静态方法的区别

> 静态方法：是被static修饰的方法，属于类所有，可以通过类名来调用；静态方法中不能使用非静态变量。
>
> 实例方法：不被static修饰的方法，只能实例化类后，再调用，是对象的方法。

## 9.构造器（构造方法）

> 构造器不可以被重写，但可以被重载（多个相同名不同参数的构造方法）。



## 10.实例变量和局部变量的区别

> 从修饰符方面看：实例方法可以被public，static，private修饰，而局部变量不能被访问控制符修饰。但两者都可以用final修饰。
>
> 从数据内存来看：实例变量是被存储在jvm堆中，而局部变量是类中方法中的变量，被存储在虚拟机栈中。
>
> 从生存时间来看：实例变量在堆内存中，随着实例的创建开始，随着实例收回结束，生存时间就是整个实例的生存时间；而局部变量是在栈中，随着方法被调用压入栈中开始，到方法结束或异常出栈而结束，生存时间是方法的生存时间。
>
> 从赋初值来看：实例对象如果没有赋初值，会在创建此对象分配内存后初始化此实例内存所有实例变量，所以实例变量不赋初值，在jvm分配内存时就会初始化一个值(除了final修饰的变量，final修饰的变量也不会初始化)；而局部变量是跟随方法进栈和出栈，没有初始化步骤，所以局部变量不初始化会抛出异常。


 ## 11.String、string buffer、string builder的理解

>String采用的是final修饰，底层实现是private final byte[] value;也就是说用的字节类型存储的，并且定义了不可被修改。
>
>StringBuffer 和 StringBuilder都是继承了abstractStringBuilder类，但是string buffer为方法添加了同步锁，更加安全，但是速度慢。而string buffer没有添加锁，不安全但是速度快。

## collections工具类

> 1.排序：
>
> > sort(List)    : 升序
> >
> > sort(List,comparator c) ：自定义排序
> >
> > reverse(List) ：对列表反序

## try-catch-finally
>try：用于捕捉异常
>
>catch：用于处理异常
>
>finally：不论异常与否，都会执行的块。
>
>> finally块不会执行的四个情况：
>>
>> 1.finally块第一行异常或错误
>>
>> 2.关闭CPU
>>
>> 3.Sys.exit()退出程序（如果sys.exit()在异常后面，那么finally还会执行）。
>>
>> 4.杀死线程。

## java多线程
>程序是指静态的文件数据，比如代码。
>线程是最小的执行单位；进程是计算机分配资源的最小单位。
>线程的基本状态：
>>1.新建状态，此时线程刚被创建，但还没有调用start()方法。
>>2.运行状态，表示线程在运行。
>>3.阻塞，表示线程没有请求到锁，被阻塞了。
>>4.等待，表示线程等待其他线程的一些动作。
>>5.超时等待，在等待时间后，线程就继续到运行状态。
>>6.结束。

## 文件与I/O流
>主要分为两类：
>1.字节流
>>输入字节流：inputstream
>>输出字节流：outstream
>
>2.字符流
>>输入字符流：reader
>>输出字符流：writer

## get和post的区别
>get和post底层都是TCP连接。
>get不安全(信息在url中包含)，post安全。
>get是向服务器请求数据，而post是向服务器提交数据。
>当Form中的method的属性为get时，调用doget()方法。
>当Form中的method的属性为post时，调用dopost()方法。
>
>###### 继续了解

## cookie和session的区别
>cookie和session都是用于跟踪浏览器用户身份的会话方式。
>cookie保存了用户的账号密码等信息，保存在客户端。
>session保存了用户的行为信息，保存在服务器端。（存储的原因时HTTP协议是无状态的，所以需要记录）

## 反射机制
>java在运行中，对于任何一个类，都可以知道这个类的属性和方法。对于任意一个类，都能够调用它的属性和方法。这种动态获取信息和动态调用对象的类的方法称为反射机制。
>可以通过.class和Class.forname（）使用。
>
>###### 还需要继续了解

## java代理
>代理简单来说就是一个类无法完全目前的任务，需要其他类的协助完成，在不改变此类属性和方法的基础上完成任务。
>
>和装饰模式相似，不过装饰模式是对此类的属性和方法进行修改后完成任务。
>
>##### 还未看完

## jad反编译
>拆箱和装箱：
>>1.拆箱：包装类转为基本类
>>2.装箱：基本类转为包装类
>反编译：
>>将java编译生成的.class文件反编译为程序员可以看懂的java代码。jad就是这样一个反编译工具。
>
>###### 继续深层了解
## java性能问题定位
>1.CPU100%
>2.内存泄漏
>3.死锁
>4.线程频繁切换
>
>###### 还需要详细理解



