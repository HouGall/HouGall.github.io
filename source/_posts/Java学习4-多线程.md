---
title: Java学习4-多线程
data: 2020-9-10 16:50:18
tags:
 - java
 - 求职
categories:
 - 求职
mathjax: true
---

### 为什么使用多线程

> 1.进程比较大，进行切换的花销比较多，也就是说如果要进行进程切换，需要大量的栈和表来维护进程使用，并且进程见都不能共享资源，而线程有大部分共享的资源，线程间切换花销比较少。
>
> 2.使用多线程的的第二个理由是多线程之间的通信方式。由于进程之间不共享资源，所以进程间的通信比较麻烦并且耗时，而线程之间有共享的资源，进行线程通信比较方便，一个线程的数据可以被其他线程所用，通信简单。

### 线程中的程序计数器、虚拟机栈、本地方法栈为什么是私有的？

> 1.程序计数器的作用记录运行的字节码位置，为下一条运行的指令指定位置，同时当线程被挂起再启用的时候，用来恢复指令执行的位置，所以是私有的。
>
> 2.虚拟机栈的作用是保存Java方法在执行时的局部变量，操作数，常量池引用信息等，一个方法的调用与执行完毕，就是一个进栈和出栈的过程。
>
> 3.本地方法栈和虚拟机栈的作用相似，不过本地方法栈存储的是native方法的信息。
>
> ###### 为了保证线程中的局部变量不被其他的线程访问到，所以虚拟机栈和本地方法栈都是线程私有的。

### 堆和方法区

> 堆是JVM中最大的内存块，存储的是创建的对象，几乎每一个new的对象都会被加到堆中，而方法区存储的是已被加载的类信息，比如类变量，常量等。

### 多线程并发带来的问题

> 并发执行的目的是提高计算机程序运行的速度，但是并发会带来一些问题，比如内存泄漏，死锁，线程不安全等。
>
> 1.上下文切换：当一个线程时间片用完，另一个线程占用CPU，称为上下文切换。
>
> ##### 2.什么是线程死锁，如何避免？
>
> > 2.1线程死锁：多个线程同时被阻塞，它们中的一个或多个都在等待某个资源的释放，由于都被阻塞，所以线程不能正常终止。（比如两个线程都在等待对方的资源，都进入了阻塞状态，造成死锁）
> >
> > 2.2死锁的四个必要条件：
> >
> > > 2.2.1.互斥条件：该资源任意时刻只由一个线程占用。
> > >
> > > 2.2.2请求与保持条件：当一个线程因请求资源阻塞后，不释放自己拥有的。
> > >
> > > 2.2.3不剥夺条件：线程对于没有使用完之前的资源不会被强行剥夺。只有在自己使用完之后才能释放资源。
> > >
> > > 2.2.4循环等待条件：进程之间互相等待对方释放资源。
> >
> > 2.3如何避免死锁：
> >
> > > 2.3.1破坏互斥条件：无法破坏，使用所得目的就是为了互斥。
> >
> > > 2.3.1破坏请求与保持条件：一次性申请所需的所有资源。
> > >
> > > 2.3.2破坏不剥夺条件：占用资源的一些线程，在申请不到自己所需要的资源时，就把自己拥有的资源释放。
> > >
> > > 2.3.4破坏循环等待条件：按某一顺序申请资源(对资源的申请顺序一致)，进行循环条件的破坏。

## sleep()和wait()方法的区别

> 都是能够使线程暂时停止执行，有以下不同点：
>
> 1.最主要的区别是：sleep()不会释放锁，而wait()会释放锁。
>
> 2.sleep()执行在一定时间后可以自动唤醒继续执行任务；而wait()在执行后不会自动唤醒，需要其他的线程执行同一对象的notify()或notifyall()来唤醒。
>
> 4.sleep()主要用在暂时停止线程，而wait()主要用在线程通信上。

## 为什么在执行start()方法后还会执行run(),而不能单独执行run()呢？

> new一个thread，会新建一个线程，并启用start()方法，表示此线程已经准备好进行任务了，当给分配了CPU后启用run()方法进行任务，这是一个多线程；但是如果单独使用run(),并没有建立一个线程，只是一个简单的函数调用，不是多线程。