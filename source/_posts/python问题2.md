---
title: python问题2
data: 2020-8-15 12:50:18
tags:
 - python
 - 求职
categories:
 - 求职
mathjax: true
---
# 4.GIL线程全局锁
>线程全局锁(Global Interpreter Lock),**即Python为了保证线程安全而采取的独立线程运行的限制**,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。

>在非python环境中，单核情况下，同时只能有一个任务执行。多核时可以支持多个线程同时执行。但是在python中，**无论有多少核，同时只能执行一个线程。究其原因，这就是由于GIL的存在导致的。**

>GIL的全称是Global Interpreter Lock(全局解释器锁)，来源是python设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，**GIL只有一个**。拿不到通行证的线程，就不允许进入CPU执行。GIL只在cpython中才有，因为cpython调用的是c语言的原生线程，所以他不能直接操作cpu，只能利用GIL保证同一时间只能有一个线程拿到数据。

## 解决方法
>解决办法就是**多进程和下面的协程**(协程也只是单CPU,但是能减小切换代价提升性能).

# 5. 协程
>又称为**微线程**，它是实现多任务的另一种方式，只不过是**比线程更小**的执行单元。因为它**自带CPU的上下文**，这样只要在合适的时机，我们可以把一个协程切换到另一个协程。,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是**用户自己控制切换的时机**,不再需要陷入系统的内核态。

>Python里**最常见的yield**就是协程的思想!

# 6.闭包
>当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包.

>比喻：
>通俗地讲就是别人家有某个东西，你想拿到但是因为权限不够（不打死你才怪），但是你可以跟家里的孩子套近乎，通过他拿到！这个家就是局部作用域，外部无法访问内部变量，孩子是从家里返回对象，对家里的东西有访问权限，借助返回对象间接访问内部变量！

## 相关代码

``` python
def outer():      #------别人家
    x = 10        #别人家里的东西（外部作用域的变量）
    def inner():   #内部函数------别人家的小孩
        print(x)   #外部函数的一个变量
    return inner   #------返回小孩
 
 
 
f = outer()        #到别人家 “套近乎”别人的小孩，套出（返回）小孩f
f()                #f小孩执行
 
 
 
# 调用inner()函数的方法
 
1、法一
outer()()   
 
2、法二
f = outer()
f()    
```
# lambda
>一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.

>lambda表达式是一行的函数。它们在其他语言中也被称为匿名函数。即，函数没有具体的名称，而用def创建的方法是有名称的。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式，它们和普通的函数完全一样。而且当使用函数作为参数的时候，lambda表达式非常有用，可以让代码简单，简洁。

>lambda语句中，**冒号前是参数**，可以有多个，用逗号隔开，**冒号右边的返回值**。lambda语句构建的其实是一个函数对象。
比如列表排序:

``` python
    a = [(1, 2), (4, 1), (9, 10), (13, -3)]
    a.sort(key=lambda x: x[1])
 
    print(a)
    # Output: [(13, -3), (4, 1), (1, 2), (9, 10)]
```

# Python函数式编程
>允许把函数本身作为参数传入另一个函数，还允许返回一个函数！
>比如map(),reduce(),filter()....

## map()
>map(func,seq)函数接收两个参数，**一个是函数**，**一个是Iterable(可迭代对象，序列)**，map将传入的函数**func()依次作用到序列seq的每个元素**，并把结果作为新的Iterator(迭代器)返回，之后可转为lis或其他类型t输出。

``` python
#!/usr/bin/python3

def f(x):
    return x*x

r = map(f, [ 1, 2, 3, 4, 5, 6 ])
print(list(r))
#由于结果r是Iterator(惰性序列)，因此通过list()函数计算整个序列
```
## reduce()
> reduce(func,seq)把一个函数作用在一个序列[x1, x2, x3, ...]上，**func函数必须接收两个参数**，reduce()把结果继续和序列的下一个元素传给func。

``` python
#!/usr/bin/python3
from functools import reduce

def f(x,y):
    return x+y

r = reduce(f, [ 1, 2, 3, 4, 5, 6 ])
print(r)
```
>map()是一次取一个元素进行运算，最终返回的还是原来列表长度的新列表；reduce是一次取两个元素进行运算，最后结果是一个值。(reduce()可以看作是对列表前两个元素进行运算，返回新的值在放入原来的列表头，在取前两个再继续运算)
### 注意
>reduce()可以对原有输入的维度进行减1操作；比如传入二维数据执行相加函数时，会对原有的列表维度减一进行拼合；但是减法报错。

## filter()
>filter(func,seq)函数用于过滤序列，调用一个布尔函数func()来迭代遍历每个seq中的元素，返回一个使func返回值为True的元素的序列。
和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

>例如求回文数字:

``` python
1 #!/usr/bin/python3
2 
3 def is_palindrone(n):
4     return str(n) == str(n)[::-1]  #[::-1]是倒切 从右往左
5 
6 print( list( filter( is_palindrone, range(11,200) ) ) )
```
## sorted()
>排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。
sorted(seq,key=func)函数也是一个高阶函数，它可以接收一个key函数来实现自定义的排序，例如按列表某一类排序。

``` python
def f(x):
    return x[1]
r = sorted([[1,2],[3,4],[0,5]],key=f)
print(r)
```